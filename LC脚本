-- 修复 identifyexecutor 函数未定义问题
local function identifyexecutor()
    return syn and "Synapse X" or "未知注入器"
end

-- 定义 addToggle 函数
local function addToggle(name, callback)
    local toggleState = false
    return {
        Toggle = function(self, state)
            if state == nil then state = not toggleState end
            toggleState = state
            callback(state)
        end,
        GetState = function()
            return toggleState
        end
    }
end

-- 修复 worldToViewport 函数未定义问题
local function worldToViewport(camera, pos)
    local onScreen, x, y = workspace.CurrentCamera:WorldToViewportPoint(pos)
    return onScreen and Vector2.new(x, y) or nil
end

-- 修复 task.delay 在标准 Roblox 环境中未定义问题
local function delay(seconds, callback)
    spawn(function()
        wait(seconds)
        callback()
    end)
end

-- 检查 Drawing API 是否可用
local Drawing = (Drawing and true) or false

-- 主代码
local library = loadstring(game:HttpGet("https://pastebin.com/raw/nBq2D86q"))()
local window = library:new("")

local creds = window:Tab("信息",'16060333448')

local bin = creds:section("玩家信息",true)
bin:Label("你的用户名:"..game.Players.LocalPlayer.Character.Name)
bin:Label("你的注入器:"..identifyexecutor())

local bin = creds:section("作者信息",true)
bin:Label("官群904830349:")
bin:Label("作者:中二病是最强的")
bin:Label("该脚本完全免费")
bin:Label("请不要倒卖")
bin:Label("每一个星期更新一次")

local credits = creds:section("关闭",true)
credits:Toggle("脚本框架变小一点", "", false, function(state)
    if state then
        game:GetService("CoreGui")["frosty"].Main.Size = UDim2.new(0.5, 0, 0.5, 0)
    else
        game:GetService("CoreGui")["frosty"].Main.Size = UDim2.new(1, 0, 1, 0)
    end
end)
credits:Button("关闭脚本",function()
    game:GetService("CoreGui")["frosty"]:Destroy()
end)

local creds = window:Tab("通用",'16060333448')

local reloadSpeed = 2 -- 设置需要的加速倍数
addToggle("快速换弹", function(on)
    if on then
        local player = game.Players.LocalPlayer
        local reloadConnection

        local function onReload(animTrack)
            if animTrack.Animation.Name:lower():find("reload") then
                animTrack:AdjustSpeed(reloadSpeed)
                local duration = animTrack.Length / reloadSpeed
                delay(duration, function()
                    if animTrack then
                        animTrack:Stop()
                    end
                end)
            end
        end

        local function onCharacterAdded(character)
            if reloadConnection then reloadConnection:Disconnect() end
            local humanoid = character:WaitForChild("Humanoid")
            local animator = humanoid:WaitForChild("Animator")
            reloadConnection = animator.AnimationPlayed:Connect(onReload)
        end

        player.CharacterAdded:Connect(onCharacterAdded)
        onCharacterAdded(player.Character)
    else
        if reloadConnection then reloadConnection:Disconnect() end
    end
end)

addToggle("敌方 ESP", function(on)
    if not Drawing then
        warn("Your executor doesn't support the use of the Drawing API.")
        return
    end

    local RunService = game:GetService("RunService")
    local Players    = game:GetService("Players")
    local camera     = workspace.CurrentCamera
    local lp         = Players.LocalPlayer
    local worldToViewport = camera.WorldToViewportPoint

    -- 颜色
    local COLOR_ENEMY = Color3.fromRGB(255,  0,  0)
    local COLOR_TEAM  = Color3.fromRGB(  0,255,  0)
    local COLOR_HEAD  = Color3.fromRGB(255,255,  0)
    local COLOR_DIR   = Color3.fromRGB( 50,255, 50)
    local COLOR_MELEE = Color3.fromRGB(220,  0,  0)   -- 刀轨
    local COLOR_BULLET= Color3.fromRGB(255,255,  0)   -- 子弹预判线

    local espCache  = {}   -- [player] = {boxLines, headDot, dirLine}
    local trackTemp = {}   -- 临时刀轨/子弹线缓存

    -- ========== 绘制工厂 ==========
    function createDrawing(type, props)
        local obj = Drawing.new(type)
        for k,v in pairs(props) do obj[k] = v end
        return obj
    end

    function destroyESP(player)
        local data = espCache[player]
        if data then
            for _, l in ipairs(data.boxLines) do l:Remove() end
            data.headDot:Remove()
            data.dirLine:Remove()
            espCache[player] = nil
        end
    end

    -- ========== 核心：更新 ESP ==========
    function updateESP(player)
        if not player.Character then return end
        local head = player.Character:FindFirstChild("Head")
        local root = player.Character:FindFirstChild("HumanoidRootPart")
        if not head or not root then return end

        local headPos, headVis = worldToViewport(camera, head.Position)
        local rootPos, rootVis = worldToViewport(camera, root.Position)
        if not headVis or not rootVis then
            local data = espCache[player]
            if data then
                for _, l in ipairs(data.boxLines) do l.Visible = false end
                data.headDot.Visible = false
                data.dirLine.Visible = false
            end
            return
        end

        local height = math.abs(headPos.Y - rootPos.Y)
        local width  = height * 0.5
        local topLeft  = Vector2.new(headPos.X - width,  headPos.Y)
        local topRight = Vector2.new(headPos.X + width,  headPos.Y)
        local botLeft  = Vector2.new(rootPos.X - width, rootPos.Y)
        local botRight = Vector2.new(rootPos.X + width, rootPos.Y)

        local myTeam = lp.Team
        local hisTeam = player.Team
        local isEnemy = (myTeam ~= hisTeam) or (myTeam == nil and player ~= lp)
        local boxColor = isEnemy and COLOR_ENEMY or COLOR_TEAM

        if not espCache[player] then
            local lines = {}
            for i = 1,4 do lines[i] = createDrawing("Line", {Thickness = 1, Color = boxColor}) end
            local dot = createDrawing("Circle", {Radius = 3, Color = COLOR_HEAD, Filled = true})
            local dir = createDrawing("Line", {Thickness = 2, Color = COLOR_DIR})
            espCache[player] = {boxLines = lines, headDot = dot, dirLine = dir}
        end

        local data = espCache[player]
        local lines = data.boxLines
        lines[1].From = topLeft  ; lines[1].To = topRight
        lines[2].From = botLeft  ; lines[2].To = botRight
        lines[3].From = topLeft  ; lines[3].To = botLeft
        lines[4].From = topRight ; lines[4].To = botRight
        data.headDot.Position = Vector2.new(headPos.X, headPos.Y - 5)

        local vel = root.Velocity
        if vel.Magnitude > 0.1 then
            local future = root.Position + vel.unit * 3
            local futPos = worldToViewport(camera, future)
